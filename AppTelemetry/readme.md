# OpenTelemetry Adapter example

## Introduction

Application telemetry refers to the collection, monitoring, and analysis of data generated by an application during its operation. This data provides critical insights into an application's performance, usage patterns, and potential issues, enabling developers and operators to optimize functionality, diagnose problems, and ensure reliability. Telemetry is essential for understanding the health and efficiency of modern distributed systems, where real-time visibility into application-level behavior is a cornerstone of successful system management. 

Telemetry data can be generated at three different levels:

* Application: Telemetry data generated when you instrument your own applications.
* Middleware: Telemetry data generated by Connext DDS entities and infrastructure services.
* System: DevOps telemetry such as CPU, memory, and disk I/O usage.

RTI® Connext® Observability Framework is a holistic solution that uses telemetry data to provide deep visibility into the current and past states of your Connext applications. This visibility makes it easier to proactively identify and resolve potential system issues, providing a higher level of confidence in the reliable operation of the system. 

At the time of writing, RTI's Observability Framework supports middleware telemetry (metrics and logs) and application logs only. While visibility into the middleware is of great value, it would be beneficial to be able to capture and include application-level metrics in the dashboards.
 
This example details the process of creating an adapter for [RTI's Routing Service](https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/connext_dds_professional/services/routing_service/index.html) to collect application-level metrics published on a DDS topic. The adapter will transform and expose this telemetry data in a format compatible with Prometheus, a widely-used open-source monitoring system. Additionally you will learn how to visualize the application-level metrics alongside Connext DDS telemetry in a Grafana dashboard, enabling a unified and comprehensive monitoring experience.  

Through this guide, you will learn to:  
1. Develop a custom Routing Service adapter for application telemetry.  
2. Configure Prometheus to scrape and display application telemetry data.  
3. Integrate application telemetry into Grafana for a combined view with Connext telemetry.  

By the end, you'll have a robust solution for monitoring both DDS system performance and application-level insights, helping you maximize the value of your telemetry data.

## Cloning the repository

To clone the repository you will need to run git clone as follows to download both the repository and its submodule dependencies:

```bash
git clone --recurse-submodule https://github.com/ajmhs/opentelemetry-adapter.git
```

If you forget to clone the repository with --recurse-submodule, simply run the following command to pull all the dependencies:

```bash
git submodule update --init --recursive
```

## Build Docker image
This example is encapsulated inside a Docker container for convenience, and once the repository has been cloned, the next step to configure a Docker image. During the image build process, the applications associated with this example will be automatically compiled and included inside the Docker image. These applications will be accessible in the resulting image at the /root/ directory.

There is a docker file in the docker subdirectory. To create the docker image adjust the line in the Dockerfile that reads ENV TZ=Europe/Madrid to set the correct timezone, then run the following command to build the Connext image for the 7.3.0 release, take into account that you are accepting the RTI license agreement by setting the RTI_LICENSE_AGREEMENT_ACCEPTED argument to "accepted":

```bash
docker build -t connext:oteladapter -f docker/Dockerfile --build-arg RTI_LICENSE_AGREEMENT_ACCEPTED=accepted --build-arg CONNEXT_VERSION=7.3.0 .
```

If you want to target a different version of Connext, then you must set the following arguments to match your requirements

* CONNEXT_VERSION: supported values are 7.3.0 and 6.1.2

Here's an example of what that would look like for a 6.1.2 release:

```bash
docker build -t connext:oteladapter -f docker/Dockerfile --build-arg RTI_LICENSE_AGREEMENT_ACCEPTED=accepted --build-arg CONNEXT_VERSION=6.1.2 .
```

## Data model

The first challenge is to come up with [a data model](generator/telemetry.idl) that reflects our needs: routing telemetry data to Prometheus via DDS. The most straight-forward way would be to establish a data model which defines a set of metrics and their associated data structures which can be easily mapped to OpenTelemetry concepts. The use of `@appendable` annotations ensures extensibility, allowing the model to evolve without breaking compatibility, which is crucial for observability frameworks like OpenTelemetry.

### IDL Data Model and OpenTelemetry Mapping

#### Module: `Metrics`
This module encapsulates all the metric-related types and definitions. In OpenTelemetry, this would correspond to the namespace or package that organizes metric-related data.

---

#### **Typedefs**
1. **`MetricName`**: A string with a maximum length of 256 characters.
   - **OpenTelemetry Mapping**: Represents the name of a metric, such as "http_requests_total" or "cpu_usage".
   
2. **`MetricDescription`**: A string with a maximum length of 512 characters.
   - **OpenTelemetry Mapping**: Provides a human-readable description of the metric, explaining its purpose or usage.

3. **`MetricUnit`**: A string with a maximum length of 64 characters.
   - **OpenTelemetry Mapping**: Specifies the unit of measurement for the metric (e.g., "seconds", "bytes", "requests").

4. **`LabelKey` and `LabelValue`**: Strings with a maximum length of 256 characters.
   - **OpenTelemetry Mapping**: Represent the keys and values of labels (or attributes) associated with metrics. Labels provide additional context, such as "region=us-west" or "status=200".

---

#### **Structs**
1. **`UInt64Counter` and `DoubleCounter`**
   - **Fields**:
     - `value`: Represents the counter value.
   - **OpenTelemetry Mapping**: These correspond to counter metrics, which are used to represent a cumulative value that only increases (e.g., total requests served).

2. **`Label`**
   - **Fields**:
     - `key`: The label key.
     - `value`: The label value.
   - **OpenTelemetry Mapping**: Represents a single label (attribute) key-value pair.

3. **`UInt64Histogram` and `DoubleHistogram`**
   - **Fields**:
     - `labels`: A sequence of `Label` structs.
     - `buckets`: A sequence of bucket values (either `uint64` or `double`).
   - **OpenTelemetry Mapping**: These represent histogram metrics, which are used to measure the distribution of values (e.g., request latency). The `labels` provide context, and the `buckets` define the histogram's distribution.

4. **`UInt64UpDownCounter` and `DoubleUpDownCounter`**
   - **Fields**:
     - `value`: Represents the counter value.
   - **OpenTelemetry Mapping**: These correspond to up-down counters, which can increase or decrease (e.g., active connections).

5. **`Int64Gauge` and `DoubleGauge`**
   - **Fields**:
     - `value`: Represents the gauge value.
   - **OpenTelemetry Mapping**: These correspond to gauges, which can increase or decrease (e.g., active connections). These are only available if the OpenTelemetry C++ Library is compiled with the ABI version as 2 or above.

---

#### **Union: `MetricUnion`**
- **Fields**:
  - Switches between different metric types (`UInt64Counter`, `DoubleCounter`, `UInt64Histogram`, `DoubleHistogram`, `UInt64UpDownCounter`, `DoubleUpDownCounter`).
- **OpenTelemetry Mapping**: Represents a polymorphic metric type, allowing a single metric to be one of several types. This is similar to how OpenTelemetry supports multiple metric types under a unified API.

---

#### **Struct: `Metric`**
- **Fields**:
  - `name`: The metric's name (keyed).
  - `description`: A description of the metric.
  - `unit`: The unit of measurement (keyed).
  - `data`: The metric data, represented by the `MetricUnion`.
  - `labels`: A sequence of `Label` structs, these allow for metric metadata, i.e. "quality".
- **OpenTelemetry Mapping**: This struct encapsulates all the information about a single metric, including its metadata (name, description, unit) and its actual data (value or distribution). It aligns closely with OpenTelemetry's metric data model.

---

## Adapter

A Routing Service adapter is a pluggable component in the RTI Routing Service that enables the service to interact with different data domains. These adapters are designed to consume and produce data from various sources, such as DDS, MQTT, sockets, files, and more. They act as a bridge between the Routing Service and the specific data domain, allowing data to flow seamlessly between them.

Adapters are responsible for:
* Input Adapters: Collecting data samples from a data domain and passing them to the Routing Service engine.
* Output Adapters: Sending data from the Routing Service to a data domain, potentially applying transformations beforehand.

The adapter architecture supports custom implementations, enabling developers to create adapters tailored to their specific integration needs. For example, a file adapter can read data from a file and send it to a DDS domain, or vice versa.

In this example, we've created an Output Adapter using [OpenTelemetry C++](https://opentelemetry.io/docs/languages/cpp/) which provides data to [Prometheus](https://prometheus.io/) through its Prometheus Exporter, which enables metrics collected by the OpenTelemetry SDK to be scraped by Prometheus. 

The first step is to initialize and configure the Prometheus Exporter in the adapter application. This involves creating an instance of the exporter and setting up the endpoint where metrics will be exposed. This is performed in [otelconnextion.cxx](src/otelconnection.cxx) where the properties required for the endpoint are read from the routing service Quality of Service definition. When the routing service asks the adapter to provide a stream writer, the adapter returns an instance of the OpenTelemetryStreamWriter class. This class' main function, write, takes a collection of samples and using the Dynamic Data API, determines the correct OpenTelemetry C++ type to create from the sample and converts the data contained in the sample to an OpenTelemetry metric.


## Configuration of the routing service

The included Routing Service configuration is an XML file that defines a setup for integrating OpenTelemetry with RTI Connext DDS. It sets up an RTI Routing Service instance named `OpenTelemetryGateway` to integrate with OpenTelemetry using a the adapter plugin. It defines:
- Configuration variables for scraping metrics and enabling debug logging.
- A plugin library (`AdapterLib`) with an adapter plugin (`OpenTelemetryAdapter`) for OpenTelemetry integration.
- A domain route (`DDSOtel`) with a connection (`OpenTelemetryConnection`) that uses the adapter plugin.

This setup is designed to enable the collection and export of telemetry data from RTI Connext DDS to Prometheus.

---

### **Configuration Variables: `<configuration_variables>`**
This section defines variables that can be used throughout the configuration.

1. **`SCRAPE_URL`**:
   - **Value**: `0.0.0.0:9464`
   - **Purpose**: Specifies the URL where metrics can be scraped. This is used for exposing metrics in a Prometheus-compatible format.

2. **`EXPORT_DEBUG`**:
   - **Value**: `true`
   - **Purpose**: Enables debug-level logging for exporting metrics. This is useful for troubleshooting and verifying the integration.

---

### **Plugin Library: `<plugin_library>`**
This section defines a custom adapter plugin for the Routing Service.

1. **`name="AdapterLib"`**:
   - The name of the plugin library.

2. **`<adapter_plugin>`**:
   - **`name="OpenTelemetryAdapter"`**: The name of the adapter plugin.
   - **`<dll>`**: Specifies the shared library (`oteladapter`) that implements the adapter.
   - **`<create_function>`**: Specifies the function (`OpenTelemetryAdapter_create_adapter_plugin`) used to create an instance of the adapter plugin.

   **Purpose**: This plugin is responsible for integrating OpenTelemetry with the Routing Service, enabling the collection and export of telemetry data.

---

### **Routing Service: `<routing_service>`**
This section defines the Routing Service instance.

1. **`name="OpenTelemetryGateway"`**:
   - The name of the Routing Service instance.

2. **Domain Route: `<domain_route>`**
   - **`name="DDSOtel"`**: The name of the domain route, which connects DDS with OpenTelemetry.

3. **Connection: `<connection>`**
   - **`name="OpenTelemetryConnection"`**: The name of the connection.
   - **`plugin_name="AdapterLib::OpenTelemetryAdapter"`**: Specifies the plugin to use for this connection. It references the `OpenTelemetryAdapter` previously defined.

   **Purpose**: This connection establishes the link between DDS and OpenTelemetry, enabling data to flow between the two systems.


## Generator

The generator is a basic Connext application that publishes random data for each metric type supported by the adapter: counter, histogram, and up-down counter. It cycles through these types, assigning random values or initializing from a random starting point.  

This enables testing of various metric types while providing the adapter with data to validate Prometheus and Grafana configurations seamlessly.

### Running the generator

The generator needs a Quality of Service file defined to execute. All the other parameters, such as domain, sample count and verbosity will default to predefined values.

    -d, --domain       <int>   Domain ID this application will
                               subscribe in.  
                               Default: 2
    -q, --qos_file     <str>   XML file containing QoS profiles
                               for the application.  
                               Required: True
    -s, --sample_count <int>   Number of samples to receive before
                               cleanly shutting down. 
                               Default: infinite
    -v, --verbosity    <int>   How much debugging output to show.
                               Range: 0-3 
                               Default: 1


From a docker container terminal window, change directory to ```/root/opentelemetry-adapter/build``` and run ```./generator -d 2 -q generator_qos.xml``` 

## Running the RTI Routing Service with the opentelemetry plugin

From a docker container terminal window, change directory to ```/root/opentelemetry-adapter/build``` and run ```rtiroutingservice -cfgFile ./RsTelemetryGateway.xml -cfgName "OpenTelemetryGateway"```

This command is used to start the RTI Routing Service with the included configuration file and specific configuration name. 

Here's a breakdown of the command:

```rtiroutingservice``` is the executable for the RTI Routing Service. It is used to start the service.

```-cfgFile```  specifies the XML configuration file to use for the Routing Service, in this case ```./RsTelemetryGateway.xml``` which is the included configuration and contains the configuration for the Routing Service, including domain routes, connections, and plugins. 

```-cfgName "OpenTelemetryGateway"``` starts the RTI Routing Service using the named configuration defined in the RsTelemetryGateway.xml file, specifically the configuration named OpenTelemetryGateway within that file. 


## Running the router+generator at the same time using tmux

To facilitate running two commands at the same time in a terminal window, the docker container includes **[tmux](https://github.com/tmux/tmux/wiki)** and a script which will start tmux, create two windows and run the routing service in the first (window 0), and the generator in the second (window 1). 

### Starting the tmux session
From a docker container terminal window, change directory to ```/root/opentelemetry-adapter/build``` and execute ```./run_tmux.sh```


### Switching between the windows
- To **switch** the tmux window, press `Ctrl-b` followed by the window number: `0` for the Routing Service, `1` for the generator.

### Exit or Detach from the session
- To **detach** the tmux session and leave it running in the background, press `Ctrl-b` followed by `d`.
- To **exit** a window, type `exit` in the window.

### Reattaching to the session
- To **attach** the tmux session either re-run the ```run_tmux.sh``` script or type ```tmux attach -t OtelAdapter```.


## Configuration of Prometheus

### Integration with RTI Observability Platform

Before completing this section, you'll need to have the RTI Observability Platform installed and configured. See [the installation instructions](https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/addon_products/observability/install.html) to find out how to do that.


### Configuration
Add a new job to the Observability platform's Prometheus configuration in {$HOME}/rti_workspace/7.3.0/user_config/observability/prometheus/prometheus.yml

Configuration options can be set in the `config.json` file. Below is an example configuration:
```yaml
scrape_configs:
  #
  # Configuration for Prometheus exporter in a system
  #      
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  #
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: 
      - localhost:9090 # Prometheus metrics
      
  - job_name: 'routing_service'      
    static_configs:
    - targets:
      - localhost:9464 # Application metrics provided by the routing service adapter - must match the url defined in the adapter configuration
```
Save and (re)start the observability platform:
```bash
rtiobservability -t && rtiobservability -i
```

Navigate in a web-browser to [the local Prometheus UI](http://localhost:9090), click on "Status" in the menu bar, then "Targets". You should see a list of all the scrape targets, including the Routing Service Adapter scrape target

![Image showing inclusion of target](resource/img/prometheus_target.png "Prometheus Target")

Clicking on the Endpoint, will open the [webpage provided by the adapter](http://localhost:9464/metrics) showing the raw metric data that Prometheus will scrape


## Grafana

Here’s a step-by-step guide and an example of adding Prometheus-provided metrics to a Grafana dashboard. There are some very helpful tutorials on the [Grafana website](https://grafana.com/tutorials/):


### **Step 1: Login to Grafana**
Open Grafana in your browser, if you are using the RTI Observability Framework, the address should be http://localhost:3000/ and log in.

---

### **Step 2: Create a New Dashboard**
1. In the Grafana menu, click **Dashboards > New Dashboard**.
2. Choose **Add visualization**.

---

### **Step 3: Query Prometheus for Metrics**
1. In the **Query** section of the panel editor:
   - Set the **Data Source** to Prometheus.
   - Enter your Prometheus query in the **Metric** field or open the **Metrics Explorer** (e.g., all the generator metrics begin with the name `rti_example`).
   - Click **Run Query** to see the result preview.
   
   Example Prometheus Queries:
   - **`prometheus_http_requests_total`**: Total number of HTTP requests.
   - **`rate(rti_example_double_counter_Micro_Fortnight_total[1m])`**: Per-second rate of Micro-Fortnights provided by the generator over the last minute.
   - **`up`**: Checks whether a target is up and running.


---

### **Step 4: Configure Visualization**
1. **Visualization Type**:
   - Choose the type of graph or chart you want (e.g., Time series, Gauge, Bar graph).
   - This option is available in the **Visualization** tab of the panel editor.
2. **Panel Options**:
   - Configure titles, units, thresholds, and other display settings.


Some of the metrics provided by the generator use textual labels like `status="good"`, `status="warning"`, `status="error"`. These can be mapped to show specific colors. To do this, in the **Overrides** tab, click **"Add field override"** → Select **"Fields with name"** and choose the metric name.
3. Under **"Value Mappings"**, click **"Add value mapping"** and define:
   - `good` → Green
   - `warning` → Yellow
   - `error` → Red

![Prometheus Overrides](resource/img/prometheus_overrides.png)
There are many more options available for customizations and transformations based on the label contents.

---

### **Step 5: Save the Dashboard**
1. Once you’re satisfied with the configuration, click **Apply**.
2. Save the dashboard with a meaningful name.

---

WARNING: If the Observability Framework is removed, ie by running ```rtiobservability -d```,  this removes all changes to your current Observability Framework Docker environment including:

* metric data in Prometheus
* log data in Loki
* **all Grafana user and dashboard configurations**



## License
See the [LICENSE](LICENSE) file for details.

## Contact
For any questions or issues, please open an issue on GitHub or contact the maintainers.

